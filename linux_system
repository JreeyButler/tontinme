#!/bin/sh

------linux安全关机
------linux 光盘刻录软件包
------linux系统调用汇总
------linux下用文件的inode删除文件
------查看是否为64位的cpu
------查看系统的发行版本
------查看系统的内核版本
------刻录设备检测

#linux安全关机
	键盘上有一个"Sys Rq"的键，在台式机的键盘上通常与"Print Screen"共健，在笔记本上可能在其他位置，\
		Delete。以台式机为例，要使用这种方法需要按住Alt-Print(Sys Rq)，然后依次按下reisub这\
		几个键，按完b系统就会重启。
	解释一下：按住Alt-Print的时候就相当于按住了Sys Rq键，这个时候输入的一切都会直接由linux内核来处理\
		它可以进行许多低级操作。这个时候reisub中的每一个字母都是一个独立操作，分别表示：
		unRaw		将键盘控制从X Server那里抢回来
		tErminate	给所有进程发送SIGTERM信号，让它们自己解决善后
		kIll		给所有进程发送SIGKILL信号，强制他们马上关闭
		Sync		将所有数据同步至磁盘
		Unmount		将所有分区挂载为只读模式
		reBoot		重启
	这6个字母的顺序可以这样记，单词busier(busy的比较级)反过来。
#linux 光盘刻录软件包
	cdrecord-2.01-10
	dvd+rw-tools-7.0-0.el5.3
	mkisofs-2.01-10
#linux系统调用汇总
	NAME		FUNCTION			MODULE
	restart_syscall
	exit		终止进程			进程控制
	fork		创建进程			进程控制
	read		读文件				文件控制
	write		写文件				文件控制
	open		打开文件			文件控制
	close		关闭文件			文件控制
	waitpid		等待指定的子进程结束		进程控制
	creat		创建文件			文件控制
	link		创建链接			文件控制
	unlink		取消链接			文件控制
	execve		运行可执行文件			进程控制
	chdir		改变当前工作目录		文件控制
	time		取得系统时间			系统控制
	mknod		创建索引节点			文件控制
	chmod		改变文件方式			文件控制
	lchown		参照chown			文件控制
	break		估计应该是被brk这个系统调用替代了内存管理
	oldlstat		
	lseek		移动文件指针			文件控制
	getpid		获取进程标识号			进程控制
	mount		安装文件系统			文件控制
	umount		卸载文件系统			文件控制
	setuid		设置用户标识号			用户管理
	getuid		获取用户标识号			用户管理
	stime		设置系统日期和时间		系统控制
	ptrace		进程跟踪			进程控制
	alarm		设置进程的闹钟			系统控制
	oldfstat
	pause		挂起进程，等待信号		进程控制
	utime		改变文件的访问修改时间		文件控制
	stty		未实现
	gtty		未实现
	access		当前进程对于文件的可存取性	系统控制
	nice		调整调用进程的优先级		进程控制
	ftime		未实现				
	sync		无参数，将内存缓冲区数据写回硬盘 内存管理
	kill		向进程或进程组发信号		进程管理
	rename		文件改名			文件控制
	mkdir		创建目录			文件控制
	rmdir		删除目录			文件控制
	dup		复制已打开的文件描述符		文件控制
	pipe		创建管道			管道
	times		取进程运行时间			系统控制
	prof		未实现				
	brk		改变数据段空间的分配		内存管理
	setgid		设置当前进程的组标识号		用户管理
	getgid		获取当前进程的组标识号		用户管理
	signal		参见signal			信号
	geteuid		获取当前进程的有效用户标识号	用户管理
	getegid		获取当前进程的有效组标识号	用户管理
	acct		启用或禁止进程记账		系统控制
	#mknod内容
		用于创建特殊文件，linux内有一个同名的命令，用于封装这个功能。通过\
			这个系统调用可以创建块专用文件、字符专用文件以及FIFO命名管道。
	#break相关内容
		这个应该被brk替代了，没有找到网上有break这个系统调用的介绍
	#lstat
		对于link文件返回link文件本身的信息，而不是所指向的文件
	#fstat
		使用fd而不是文件名路径作为参数
	#为了支持64位系统，Linux增加了几个64bit版本的stat系统调用
		stat64,fstat64,lstat64
	#linux0.12中定义了许多系统调用，相当多没有实现，应该是考虑向后兼容一些UNIX功能
	#这个页面列出了linux2.6定义仍然没有实现的系统调用
		http://www.kernel.org/doc/man-pages/online/pages/man2/mpx.2.html
		afs_syscall,  break,  ftime, getpmsg, gtty, lock, madvise1, mpx, \
			prof, profil,putpmsg, security, stty, tuxcall, ulimit, vserver
	#其中还提供了一些有用的信息：
		ftime,profil,ulimit这几个系统调用在用户空间以lib的方式实现了，因此\
			没有必要提供系统调用
		一些系统调用只有在特定的CPU上支持：alloc_hugepages,free_hugepages,ioperm,\
			ioperm,iopl,vm86
		一些系统调用只有打开了编译选项才会包括进来（比如：ipc,create_module,\
			init_module,delete_module）
	#dup
		请移步：http://blog.csdn.net/AllanZeng/archive/2009/06/12/4264111.aspx
	#有关effective ID和Real ID的区别
		请移步：http://whatilearned2day.wordpress.com/2007/01/09/uid-gid-real-and-effective-difference/	
#linux下用文件的inode删除文件
	如果不小心创建了含有特殊字符的文件和目录，比如带有?*^的文件名，就很难删除
	#找出文件和目录的inode
		stat & ls -il
	#通过inode删除该文件
		find . -inum [inode num] -exec rm -i {} \;
#查看是否为64位的cpu
	#打入以下命令
	$grep flags /proc/cpuinfo
	输出：
	flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov \
		pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm nx lm
	如果找到lm，说明你的cpu是64位的.
	lm	Long Mode —— 64位CPU
	rm	Read Mode —— 16位CPU
	pm	Protected Mode —— 32位CPU
#查看系统的发行版本
	$lsb_release -a
#查看系统的内核版本
	$uname -a
#刻录设备检测
	cdrecord -scanbus	#用于SCSI光驱
	cdrecord -scanbus dev=APAPI

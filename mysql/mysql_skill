------mysql bin-log 清除(purge)
------mysql重置密码
------导出MySQL所有用户权限

#mysql重置密码
	$/usr/local/mysql/share/mysql/mysql.server stop
	$/usr/local/mysql/bin/mysqld_safe --user=mysql --skip-grant-tables --skip-networking &
	$/usr/local/mysql/bin/mysql -u root mysql
	mysql> update user set password=PASSWORD("newpassword") where user='root';
	mysql> flush privileges;
	mysql> quit
	$/usr/local/mysql/share/mysql/mysql.server restart
	$/usr/local/mysql/bin/mysql -u root -p
	#更优雅一点儿
	把用到的语句保存到一个文本文件中(比如/path/to/init/file)
	update user set password=PASSWORD("newpassword") where user='root';
	flush privileges;
	接着使用init-file参数启动mysql
	$/usr/local/mysql/share/mysql/mysql.server stop
	$/usr/local/mysql/bin/mysqld_safe --init-file=/path/to/init/file &
	此时，密码就已经被重置了。最后别忘了删除文件内容，以免密码泄漏
	官方关于mysql重置密码的介绍：http://dev.mysql.com/doc/refman/5.5/en/resetting-permissions.html
#mysql bin-log 清除(purge)
	>purge {master | binary} logs to 'log_name'
	>purge {master | binary} logs before 'date'
	#example
	  >purge master logs to 'mysql-bin.002';
	  >purge master logs before '2010-12-31 24:00:00';
	  #清楚3天前的binlog
	  >purge master logs before date_sub(now(),interval 3 day);
	#如果您有一个活动的从服务器，该服务器当前正在读取您正在试图删除的日志之一，则本语句不会起作用，而是会\
		失败，并伴随一个错误。不过，如果从服务器是休止的，并且您碰巧清理了其想要读取的日志之一，则从服务器\
		启动后不能复制。当从服务器正在复制时，本语句可以安全运行，您不需要停止它们。
	#清理日志的步骤：
	1.在每个从服务器上，使用show slave status来检查它正在读取哪个日志。
	2.使用show master logs获得主服务器上的一系列日志
	3.在所有从服务器中判定最早的日志，这个是目标日志。如果所有的从属服务器是更新的，这是清单上的最后一个日志
	4.制作您想要删除的所有日志的备份
	5.清理所有的日志，但是不包括目标日志
#导出MySQL所有用户权限
	默认情况下，如果使用
	  select * from mysql.user;
	导出的只是全局权限，要想查看每个用户的具体权限，要使用
	  show grants for "user"@'host';
	导出mysql所有用户权限
	  #!/bin/bash
	  #function export user privileges
	  expgrants()
	  {
		mysql -B -u'root' -p'123456' -N $@ -e "SELECT CONCAT(
			'SHOW GRANTS FOR ''', user, '''@''', host, ''';'
			) AS query FROM mysql.user" | \
		mysql -u 'root' -p '123456' $@ | \
		sed 's/\(GRANT .*\)/\1;/;s/^\(Grants for .*\)/-- \1 /;/--/{x;p;x}'
	  }
	  expgrants > ./grants.sql

#Linux performance metrics
	#Processor metrics
		#CPU utilization
			It describes the overall utilization per processor
			If the CPU utilization exceeds 80% for a sustained period of time,a processor\
				bottleneck is likely
		#User time	
			Depicts the CPU percentage spent on user processes,including nice time.
			High values in user time shows that the system performs actual work.
		#System time
			Depicts the CPU percentage spent on kernel operations including IRQ and softirq time
			High and sustained system time values can point you to bottlenecks in the \
				network and driver stack.
		#Waiting
			Total amount of CPU time spent waiting for an I/O operation to occur.
			A system should not spend too much time waiting for I/O operations.
		#Idle time
			Depicts the CPU percentage the system was idle waiting for tasks.
		#Nice time
			Depicts the CPU percentage spent on re-nicing processes that change the execution \
				order and priority of processes.
		#Load average
			The load average is the rolling average of tht sum of the following:
			 - The number of porcesses in queue waiting to be processesed
			 - The number of processes waiting for uninterruptable task to be completed.
			If processes that request CPU time are blocked (which means that the CPU has no \
				time to process them), the load average will increase. On the other hand,\
				the load will decrease.				
		#Runable processes
			This value depicts the processes that are ready to be executed.
			This value should not exceed 10 times the amount of physical processors for a sustained \
				period of time.
		#Blocked
			Processes that cannot execute while they are waiting for an I/O operation to finish.
			Blocked processes can point you toward an I/O bottleneck.
		#Context switch
			Amount of switches between threads that occur on the system.
			High numbers of context switches in connection with a large number of interrupts can \
				signal driver or application issues.
		#Interrupts
			The interrupts value contains hard interrupts(more adverse effect) and soft interrupts.
			High interrupt values are an indication of a software bottleneck, either in the kernel \
				or a driver.
			Remember that the interrupt value includes the interrupts caused by the CPU clock.
	#Memory metrics
		#Free memory
			The linux kernel allcates most unused memory as file system cache, so subtract the amout\
				of buffers and cache from the used memory to determine(effectively) free memory.
		#Swap usage
			This value depicts the amount of swap space used.
			Values above 200 to 300 pages per second for a sustained period of time express a likely \
				memory bottleneck.
		#Buffer and cache
			Cache allocated as file system and block device cache.
		#Slabs	
			Depicts the kernel usage of memory.
			Note that kernel pages cannot be paged out to disk.
		#Active versus inactive memory
			Provides you with information about the active use of the system memory.
			Inactive memory is a likely candidate to be swapped out to disk by the kswapd daemon.
	#Network interface metrics
		#Packets received and sent
			This metric informs you of the quantity of packets received and sent by a given network\
				interface.
		#Bytes received and sent
			This value depicts the number of bytes received and sent by a given network interface.
		#Collisions per second
			This value provides an indication of the number of collisions that occur on the network\
				that the respective interface is connected to.
			Sustained values of collisions ofter concern a bottleneck in the network infrastructure.
		#Overruns
			Overruns represent the number of times that network interface ran out of buffer space.
			This metric should be used in conjunction with the packets dropped value to identify a \
				possible bottleneck in network buffers or the network queue length.
		#Error
			The number of frames marked as faulty. 
			This is often caused by a network mismatch or a partially broken network cable.
	#Block device metrics
		#Iowait
			Time the CPU spends waiting for an I/O operation to occur.
			High and sustained values most likely indicate an I/O bottleneck.
		#Average queue length
			Amount of outstanding I/O requests.
			In general, a disk queue of 2 to 3 is optimal; higher values might point toward a disk\
				I/O bottleneck.
		#Average wait
			A measurement of the average time in ms it takes for an I/O request to be serviced. The\
				wait time consists of the actual I/O operation and the time it waited in the I/O queue.
		#Transfers per second
			Depicts how many I/O operations per second are performed(read and writes).
			The average tranfer size generally should match with the stripe size used by your disk subsystem.
		#Blocks read/write per second
			This metric depicts the reads and writes per second expressed in blocks of 1024 bytes as of kernel\
				2.6.
		#Kilobytes per second read/write
			Reads and writes from/to the block device in kilobytes represent the amount of actual data \
				transferred to and from the block device.
#Monitoring and benchmark tools			
	#Overview of tool functions
		top			process activity
		vmstat			system acitve, hardware and system information
		uptime,w		average system load
		ps,pstree		displays the processes
		free			memory usage
		iostat			average CPU load, disk activity
		sar			collect and report system activity
		mpstat			multiprocessor usage
		numstat			NUMA-related statistics
		pmap			process memory usage
		netstat			network statistics
		iptraf			real-time network statistics
		tcpdump,ethereal	detailed network traffic analysis
		nmon			collect and report system activity
		strace			system calls
		proc file system	various kernel statistics
		KDE system guard	real-time systems reporting and graphing
		gnome system monitor	real-time systems reporting and graphing

		lmbench			microbenchmark for operating system functions
		iozone			file system benchmark
		netperf 		network performacd benchmark
		netperf			network perfor
        #benchmark tools
          #LMbench
                LMbench is a suite of microbenchmarks that can be used to analyze different operating \
                  system settings. Such as an SELinux enabled system versus a non SELinux system
	  #IOzone
		IOzone is a file sstem benchmark that can be utilized to simulate a wide variety of different\
		        disk access patterns
		Since the configuration possibilities of IOzone are detailed,it is possible to simulate a \
		        targeted workload profile precisely. IOzon writes one or multiple files of varible size using\
		        block sizes
          #netperf
                netperf is a performance benchmark tool that focuses on TCP/IP networking performance.It support\
                        UNIX domain socket and SCTP benchmarking
          #other useful tools
                bonnie          Disk I/O and ifle system benchmark
                bonnie++        Disk I/O and ifle system benchmark
                NetBench        File server benchmark. It runs on Windows
                dbench          File system benchmark. Commonly used for file server benchmark
                iometer         Disk I/O and network benchmark
                ttcp            Simple network benchmark
                nttcp           Simple network benchmark
                iperf           Network benchmark
                ab(Apache Bench)Simple web server benchmark. It comes with Apache HTTP server
                WebStone        used mainly for web server performance benchmarking.
                fsstone,smtpstone
                                Mail server benchmark. They come with Postfix
                nhfsstone       Network File System benchmark. Comes with nfs-utils package
                DirectoryMark   LDAP benchmark
#chapter 3 Aanlyzing performance bottlenecks
        #identifying bottlenecks
          Step:
                1.know your system
                2.back up the system
                3.monitor and analyze the system performance
                4.Narrow down the bottleneck and find its cause
                5.fix the bottleneck cause by trying one change at a time
                6.go back to step 3 until you are satisfied with the performance of the system
          Gathering information
                a complete description of the server
                  -model
                  -age
                  -configuration
                  -peripheral equipment
                  -operating system version and update level
                describle problem
                  -what are the symptoms
                  -describe any error messages
                Who is experiencing the problem?
                  one person, one particular group of people, or?
                  This helps determine whether the problem exists in one particular part of the network, whether\
                        it is application-dependent, and so on
                Can the problem be reproduced
                  All reproducible problems can be solved.
                Document the sequence of actions that are necesary to reproduce the problem
                  -What are the steps to reproduce the problem
                  -Is it an intermittent problem
                  -Does it occur at certain times of the day or certain days of the week
                  -Is it unusual 
                When did the problem start? Was it gradual or did it occur very quickly
                  If the performance issue appeared gradually, then it is likely to be a sizing issue; if it appeared \
                        overnight, thne the problem could be caused by a change made to the server or peripherals
                Have any changes been made to the server(minor or major) or are there any changes in the way clients\
                        are using the server
                Demands could change based on business changes, which could affect demands on a server and network systems
                  >Are there any other servers or hardware components involved
                  >Ary any logs available
                  >Whats is the priority of the problem? When does it have to be fixed
          Analyzing the server's performance '
                #Note: Before taking any troublesshooting actions, back up all data and the configuration information\
                        to prevent a partial or complete loss
                A performance log of the server should be created during its peak time of operation; it will depend on \
                        what services are being provided and on who is using these services. If available, the following\
                        objects should be included:
                  >Processor
                  >System
                  >Server work queues
                  >Memory
                  >Page file
                  >Physical disk
                  >Redirector
                  >Network interface
                Our recommended process, which you can use for your server performance tuning process, is as follow:
                  1.Understand the factors affecting server performance
                  2.Measure the current performance to create a performance baseline to compare with your future \
                        measurements and to identify system bottlenecks
                  3.Use the monitoring tools to identify a performance bottleneck.
                  4.Work with the component that is causing the bottleneck by performing some actions to improve\
                        server performance in response to demands 
                  5.Measure the new performance. This helps you compare performance before and after the tuning steps
                When attempting to fix a performance problem, remember the following:
                  >Application should be compiled with an appropriate optimization level to reduce the path length
                  >Take measuerments before you upgrade or modify anything so that you can tell whether the change\
                        had any effect
                  >Examine the options that involve reconfiguring existing hardware, not just those that involve \
                        adding new hardware
        #CPU bottlenecks
          finding CPU bottlenecks
                uptime  we can get a rough idea of what has been happening in the system for the past 15 minutes
                top
                sar     or $sar -u or $sar -U PROCESSOR_NUMBER
                vmstat
          SMP
                SMP-based systems can present their own set of interesting problems that can be difficult to detect
          Performance tuning options 
                The first step s to ensure that the system performance problem is being caused by the CPU. then a \
                        number of actions can be takenn to improve performance.
                  >Ensure that no unnecessary programs are running in the background by using ps -ef. 
                  >Identify non-critical, CPU-intensive processes by using top and modify their priority using renice
                  >In an SMP-based machine, try using taskset to bind processeds to CPUs to make sure that processes\
                        are not hoping between processors, causing cache flushes
                  >BAsed on he running application, it might be better to scale up(bigger CPUs) than to scale out(more\
                        CPUs)
                  >General options include making sure you are using the latest drivers and firmware
        #Memory bottlenecks
          Note:Page space is a file created by the OS on a disk partition to store user programs that are not currently\
                in use. Typically, page sizes are 4KB or 8KB
          Finding memory bottlenecks
                Memory available        This indicates how much physical memory is available for use.
                Page faults             soft page faults -- when the page is found in memory
                                        hard page faults -- when the page is not found in memory and must be fetched from disk
                                        the $sar -B command can provide useful information for analyzing page faults
                File system cache       This is the common memory space used by the file system cache.
                                        Use the $free -l -t -o command for additional information
                Private memory for process
                                        This represents the memory used by each process running on the server
                                        You can use the $pmap command to see how much memory is allocated to a specific process
          Paging and swapping indicators
                There are differences between paging and swapping. Paging moves individual pages to swap space on the disk;
                  Swapping is a bigger operation that moves the entire address space of a process to swap space in one operation
                Swapping can have one of two causes:
                  A process enters sleep mode.
                  A process behaves poorly. 
                If your server is always paging to disk (a high page-out rate), consider adding more memory.
                  However, for systems with a low page-out rate, it might not affect performance
          Performance tuning options
                >Tune the swap space using bigpages, hugetlb, shared memory
                >Increase or decrease the size of pages
                >Improve the handling of active and inactive memory
                >Adjust the page-out rate
                >Limit the resources used for each user on the server
                >Stop the services that are not needed
                >Add memory
        #Disk bottleneck
          Note: The most common disk bottleneck is having too few disks. Most disk configurations are based on \
                  capacity requirements,not performance
                The second most common problem is having too many logical disks on the same way
          Finding disk bottlenecks
                A server exhibiting the following symptoms might be suffering from a disk bottleneck(or a hidden memory problem)
                  >show disks will result in:
                          -Memory buffers filling with write data(or waiting for read data)
                          -Insufficient memory, as in the case of not enough memory buffers for network requests, \
                                will cause synchronous disk I/O
                  >Disk utilization, controller utilization, or both will typically be very high
                  >Most LAN transfers will happen only after disk I/O has completed, causing very long response \
                          times and low network utilization
                  >Disk I/O can take a relatively long time and disk queues will become full
                Note: Given the I/O profile of 70% reads and 30% writes of the average commercial workload. a \
                        RAID-10 implementation will perform 50% to 60% better than a RAID-5
                There are two ways to approach disk bottleneck analysis: real-time monitoring and tracing.
                  >Real-time monitoring must be done while the problem is coming 
                  >Tracing is the collecting of performance data over time to diagnose a problem
                vmstat
                  The columns in vmstat with respect to I/O are the bi and bo fields. These fields monitor the\
                        movement of blocks in and out of the disk subsystem
                iostat
                  Performance problems can be encountered when too many files are opened, read and written to,\
                        then closed repeatedly.
                  Using then iostat tool, you can monitor the I/O device loading in real time
          Performance tuning options
                After verifying that the disk subsystem is a system bottleneck, several solutions are possible:
                  >If the workload is of a sequential nature and it is stressing the controller bandwidth, the \
                        solution is to add a faster disk controller
                  >Add more disk drives in a RAID environment. This improves performance for both reads and writes
                     Also, use hardware RAID instead of the software implementation provided by Linux. If \
                        hardware RAID is hidden from the OS   
                  >Consider using Linux logical volumes with striping instead of large single disks or logical\
                        volumes without striping
                  >Offload processing to another system in the network(users, applications, or services)
                  >Add more RAM, Adding memory increases system memory disk cache, which in effect improve \
                        disk rsponse times
        #Network bottlenecks
          Finding network bottlenecks
                Indicators for network analysis
                  Packets received      shows the number of packets that are coming in and going out of the\
                  Packets sent                  specified network interface
                  Collision packets     Collisions occur when there are many systems on the same domain
                  Dropped packets       packets may be dropped for a variety of reasons, but the result can \
                                                affect performance
                  Errors                Errors occur if the communication lines are of poor quality
                  Faulty adapters       Network slowdowns often result from faulty network adapters
          Performance tuning options
                What you should do to solve problems
                  >Ensure that the network card configuration matches router and switch configurations(eg. frame size)
                  >Modify how your subnets are organized
                  >Use faster network cards
                  >Tune the appropriate IPv4 TCP kernel parameters.
                  >If possible, change network cards and recheck performance
                  >Add network cards and bind them together to form an adapter team, if possible
#chapter 4 Tuning the operating system
	#Tuning principles
	  The first stop should be to analyze and evaluate the current system configuration.
	  And also prior should have a minimumu of unnecessary tasks and subsystems running
	  Finally when moving towards specific systems tuning, it should be noted that tuning often tailors a \
		system towards a specific workload. So, the system will perform better under the intended load \
		characteristics but it will probably perform worse for different workload patterns
	  Change management
	  	>Implement a proper change management process before tuning any Linux system
		>Never start tweeking settings on a production system
		>Never change more than one variable during the tuning process
		>Retest parameters that supposedly improved performance, sometimes statistics come into play
		>Document successful parameters and share them with the community no matter how trivial you\
			think they are
	#Installation considerations
	  Installation
		Select the correct kernel
		  Standard	Single processor machines
		  SMP		Kernel has support for SMP and hyper-threaded machines.
				Some packages also include support for NUMA
				There may be some variant, depending on the amount of memory,CPU,and so on
		  Xen		Includes a version of the Linux kernel which runs in a Xen virtual machine
		What partition layout to choose
		  The partition layout will be given in most cases. Our only suggestion is that you should use\
		  a swap partition if possible
		What file system to use
		Package selection:minial or everything
		Netfilter configuration
		  The netfilter firewall should be used to protect the system from malicious attacks
		  Having too many complicated firewall rules could decrease performance in high data traffic environment
		SELinux
		Runlevel selection
		  Unless you have a specific need to run your system in runlevel 5(graphical user mode), we \
			strongly suggest using runlevel 3 for all server systems
	  Check the current configuration
		dmesg
		  The main purpose of dmesg is to display kernel messages
		  dmesg can provide helpful information in case of hardware problems or problems with loading\
			a module into the kernel
		  In addition, with dmesg, you can determine what hardware is installed on your server
		  View these logs using the command /bin/dmesg
		ulimit
		  This command is used to provide control over the resources available to the shell and to the\
		 	processes started by it on systems that allow such control
		  -a 	list all parameters that we can set
		  -H & -S	specify the hard and soft limits that can be sent for the given resource.
	  Minimize resource use
		Tunable daemons started on a default installation
		  apmd		Advanced power management daemon
				#apmd will usually not be used on a server
		  arptables_if	User space program for the arptables network filter
				#Unless you plan to use arptables, you can safely disable this daemon
		  autofs	Automatically mounts file systems on demand(eg. mounts a CD-ROM automatically)
				#On server system, file system rarely have to be mounted automatically
		  cpuspeed	Daemon to dynamically adjust the frequency of the CPU
				#In a server environment, this daemon is recomended off
		  cups		Comman UNIX Printing System.	
				#If you plan to provide print services with your server, do not disable this service
		  gpm		Mouse server for the text console.
				#Do not disable if you want mouse support for the local text console
		  hpoj		HP OfficeJet support.
				#Do not disable if you plan to use an HP OfficeJet printer with your server
		  irqbalance	Balances interrupts between multiple processors
				#You may safely disable this daemon on a singe CPU system or if you plan to \
					#balance IRQ statically
		  isdn		ISDN mmodem support
				#Do not disable if you plan to use an ISDN modem with your server
		  kudzu		Detects and configure new hardwares
				#Should be run manually in case of a hardware change
		  netfs		Used in support of exporting NFS shares
				#Do not disable if you plan to provide NFS shares with your server
		  nfslock	Used for file locking with NFS
				#Do not disable if you plan to provide NFS shares with your server
		  pcmcia	PCMCIA support on a server
				#Server  systems rarely rely on a PCMCIA adapter so disabling this daemon is \
					#safe in most instances
	  	  portmap	Dynamic port assignment for RPC services(such as NIS and NFS)
				#If the system does not provide RPC-based services there is no need for this daemon
		  rawdevices	Provides support for raw device bindings
				#If you do not intend to use raw devices you may safely turn if off
		  rpc*		Various remote procedure call daemon mainly used for NFS and Samba
				#If the system does not provide RPC-based services there is no need for this daemon
		  sendmail	Mail Transport Agent
				#Do not disable this daemon if you plan to provide mail services with the \
					#respective system
		  smartd	Self Monitor and Reporting Technology daemon that watches S.M.A.R.T.compatible\
					 devices for error
		  		#Unless you use an IDE/SATA technology based disk subsystem, there is no need \
					#for S.M.A.R.T.Mnoitoring	
		  xfs		Font server for X Windows
				#If you will run in runlevel 5, do not disable this daemon
		/sbin/chkconfig		provides the administrator with an easy-to-use interface to change \
						start options for various daemons
					#Note:Instead of wasting time waiting for a reboot to complete, simple\
						#change the run level to 1 and back to 3 or 5, respectively
		/sbin/service		this enables an administrator to immediately change the status of any \
						registered
					Or use /etc/init.d/
	  	Changing runlevels
	  	  $runlevel	Determine which run level the machine is running
	  	  		eg. N 5 means that there was no previous run level and that the current run level is 5
	  	  $init		To switch between run levels, use the init command
	  	  To set the initial runlevel of a machine at boot, modify the /etc/inittab file
	  	Limiting local terminals
	  SELinux
		SELinux enforces security on user and process levels
		Every access from a user or process to a system resource such s an I/O device must be \
			controlled by SELinux.
		The prcesses of checking permissions can cause overhead of up to 10%
		Disable SELinux
		  1.do not install SELinux
		  2.append the entry selinux=0 to the line containing kernel in the GRUB boot loader
		  3.Edit /etc/selinux/config. append or modify parameter "SELINUX=disabled"
	  Compiling the  kernel
		performance improvements can be gained with a custom made kernel, but they hardly justify the \
			challenges your face runing an enterprise environment
		Do not attemp to use special compiler flags such as -C09 when recompiling the kernel. The \
			source code for the Linux kernel has been hand tuned to match the GNU C compiler
	#Changing kernel parameters
	  To view the current kernel configuration, choose a kernel parameter in the /proc/sys directory and \
		use the cat command on the repective file
	  Where the parameters are stored
		The kernel parameters that control how the kernel behaves are stored in /proc(in particular, /proc/sys)
		Each process running in the system has a directory in /proc with the process ID(PID) as its name
		Parameter files in /proc
		  /proc/sys/abi/*	Used to provide support for "foreign" binaries, not native to Linux
					By default, this support is installed, although it can be removed during installation
		  /proc/sys/fs/*	Used to increase the number of open files the OS allows and to handle quota
		  /proc/sys/kernel/*	For tuning purposes, you can enable hotplug, manipulate shared memory,\
						 and specify the maximun number of PID files and level of debug in syslog
		  /proc/sys/net/*	Tuning of network in general, IPv4 and IPv6
		  /proc/sys/vm/*	Management of cache memory and buffer
	  Using the sysctl command
		sysctl uses the names of files in the /proc/sys drectory tree as parameters
		$cat /proc/sys/kernel/shmmax
		$sysctl kernel.shmmax
		  -w	#Use this option when you want to change a sysctl setting
		  -p 	#Load in sysctl settings from the file specified or /etc/sysctl.conf if none given
		  -a	#Display all values currently available
	#Tuning the processor subsystem
	  Tuning process priority
	  	It is not possible to change the process priority of a process. This is only indirectly possible\
			through the use of the nice level of the process, but even this is not always possible
		If a process is running too slowly, you can assign more CPU to it by giving it a lower nice level.
		Linux supports nice levels from 19(lowest priority) to -20(highest priority). The default value is 0
		$nice & $renice 	#Change nice of process
	  CPU affinity for interrupt handling
		>Bind processes that cause a significant amount of interrupts to a CPU
		>Let physical processors handle interrupts
	  Considerations for NUMA systems
	#Tuning the vm subsystem
	  #If you do choose to modify the virtual memory parameters(in /proc/sys/vm), we recommend that you \
		#change only one parameter at a time and monitor how the server performs
	  Setting kernel swap and pdflush behavior
		>The parameter stored in /proc/sys/vm/swappiness can be used to define how aggressively memory\
			 pages are swapped to disk ($sysctl -w vm.swappiness=100)
		>The value stored in /proc/sys/vm/dirty_background_ratio defines at what percentage of main memory\
			the pdflush daemon should write data out to the disk
		  #If larger flushes are desired then increasing the default value of 10% to a larger value \
			#will cause less frequent flushes
		>Using the parameter stored in /proc/sys/vm/dirty_ratio the system administrator can define at \
			what level the actual disk writes will take place
		  #A value of 10 would mean that data will be written into system memory until the file system \
			#cache has a size of 10% of the server's RAM
	  Swap partition
		The swap device is used when physical RAM is fully in use and the system needs additional memory
		Linux kernels 2.4 and beyond support swap sizes up to 24GB per partition with an 8TB theoretical\
			 maximum for 32-bit systems
		Linux can take advantage of multiple swap partitions or files and perform the reads and writes\
			in parallel to the disks
		If you have multiple swap partitions, you can change priority level of them by modifying /etc/fstab
			eg. $vim /etc/fstab
			    /dev/sda2	swap	swap	sw,pri=3	0 0 
			    ...
			swap partitions are used from the highest priority to tht lowest(where 32767 is the \
				highest and 0 is the lowest)
	  HugeTLBfs
		This memory management feature is valuable for application that use a large virtual address\
			space. It is especially useful for database applications
		The CPU's ' Translation Lookaside Buffer(TLB) is a small cache used fro storing virtual-to-physical\
			mapping information
		To keep translations as fast as possible, the TLB is usually small. It is not uncommon for \
			large memory applications to exceed the mapping capacity of the TLB
		To allocate hugepage, you can define the number of hugepages 
		  $sysctl -w vm.nr_hugepages=125
		  $cat /proc/sys/vm/nr_hugepages
		If your application uses huge pages through the mmap() system call, you have to mount a file\
			system of type hugetlbfs like this :
		  $mount -t hugetlbfs none /mnt/hugepages
		/proc/meminfo file will provide information about hugetlb pages
	#Tunning the disk subsystem
	  Hardware considerations before installing linux
	  	If it is necessary to implement a hardware RAID array, you will need a RAID controller for \
			your system 
		There are benefits to running Linux on a multipartitioned or even logical volume disk:
		  >Improved security with finer granularity on file system attributes
		  >Improved data integrity, so loss of data with a disk crash would be isolated to the affected\
		  	partition
		  >New installations and upgrades can be done without affecting other more static partitions
		  >More efficient backup process
		Linux partitions and server environments
		  /home		This is the home directory for all users on the system
		  /tmp		If you are running a high-performance computing environment, large amounts of \
		  			temporary space are needed during compute time, then released upon completion
		  /usr		This is where th kernel source tree and Linux documentation are located. 
		  		The /usr/local directory stores the executables that must be accessed by all \
					users on the system and is good location to store custom scripts developed\
					for your environment
		  /var		The /var partition is important in mail, Web and print server environment, because\
		  			it contains the log files for these environments and the overall system log
				Further separation of this partition is possible by separating out /var/spool/mail\
					for a mail server or /var/log for system logs
		  /opt		The installation of some third-party software products
	  I/O elevator tuning and selection
	  	Select the rithe I/O elevator in kernel 2.6
		  The administrator now has the possibility to isolate a specific I/O pattern on a disk subsystem \
		  	and select the appropriate elevator algorithm
		Impact of nr_requests
		  The plugable I/O scheduler implementation of kernel 2.6 also features a way to increase or decrease\
		  	the number of requests that can be issued to a disk subsystem

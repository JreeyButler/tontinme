#!/bin/bash
---Index
------adduser&useradd
------at
------alias
------chroot
------cp
------crontab
------dd
------find
------free
------grep
------iostat
------iptraf
------ls
------lsof
------man
------mpstat
------netstat
------nmon
------od
------paste
------pmap
------ps
------rpm
------rsync
------sar
------ss
------strace
------su & sudo
------tail
------tcpdump
------tmpwatch
------top
------uptime
------vmstat
------w
------watch
------wget
------whoami,id,groups,newgrp
------zip,tar.gz,tar.bz2
#adduser&useradd
	#Debian/Ubuntu
		useradd is a command itself, and you can create users and define options to them using this \
			command.
		adduser is a perl command, that uses useradd to create the account. asking you the password \
			full-name,phone, and others...
	#Fedora/Centos
		adduser is just a symbolic link to useradd, but may try to copy the script from a Debian system\
			to the Centos one
	#Gentoo
		on Gentoo systems, is the same as in Centos or Fedora, adduser is just a symbolic link to useradd
	#使用
		请咨询man手册
#at
	at命令允许用户向cron守护提交作业，使其在稍后的时间运行。
	一旦一个作业被提交，at命令将会保留所有当前的环境变量。不像crontab，只提供缺省的环境。
	该作业的所有输出都将以电子邮件形式发送给用户，除非你对其输出进行了重定向。
	和crontab一样，根用户可以通过/etc目录下的at.allow和at.deny文件来控制哪些用户可以使用at命令。
	at [-f script][-m -l -r][time][date]
		-f script	所要提交的命令或脚本
		-l 		列出当前所有等待运行的作业。$at q 具有相同的作用
		-r		清除作业。为了清除某个作业，还要提供相应的作业标识ID；有些linux变体只接受$at rm作为
					清除命令
		-m		作业完成后给用户发邮件
	at的时间格式非常灵活：可以是H、HH、HHMM、HH:MM或者H:M，其中H和M分别是小时和分钟。还可以使用am或pm
	使用at提交命令
		可以通过命令行方式，也可以使用at命令提示符($at 21:00)
		eg. $at 3.00pm tomorrow -f example.sh
#alias
	#工作中可能会经常删除一些core文件，可以这样定义到profile文件
		$alias rmcore="find . iname core -exec rm {} \;"	#iname表示忽略大小写
	#工作中可能经常要删除一些log文件，可以这样定义：
		$alias rmlog="find /logs -type f -name *.tar -size +500M -exec rm -i {} \;"
		$alias rmlg="find / -type f -name *.tar -size +1G -exec rm -i {} \;"
#chroot
	#即change root directory，经过chroot后，系统读取到的目录和文件将不再是旧系统根下的而是新\
		根下（即被指定的新的位置）的目录结构和文件，因此带来三个好处：
		1. 增加了系统的安全性，限制了用户的权利
		2. 建立一个与原系统隔离的系统目录结构，方便用户的开发
		3. 切换系统的根目录位置，引导linux系统启动以及急救系统等。
#cp
	#取消覆盖提示
		有时使用$cp -f file dir，系统仍然会有覆盖提示
		原因是系统将cp命令alias为cp -i
		两种解决办法：
			1.修改该alias	仅针对当前用户的，在用户的home目录下修改.bashrc即可
			  		针对全局的，修改/etc/bashrc
			2.使用如下命令	$\cp -f file dir
#crontab
	#注意：
	  最好建立一个crontab的副本进行编辑，然后执行
	  $crontab ${NAME_CRON}
	  导入配置防止对crontab的误删操作
	系统管理员通过cron.deny和cron.allow这两个文件来禁止或允许用户拥有自己的crontab文件。
	-u	用户名
	-e 	编辑crontab文件
	-l	列出crontab文件的内容
	-r	删除crontab文件
	#field		allowed values
	minute		0-59		#每分钟用*或*/1表示
	hour		0-23		#0表示0点
	day of month	1-31
	month		1-12 (or names)
	day of week	0-7 (0 or 7 is Sun, or use names)
	#crontab [-e [UserName] | -l [UserName] | -r [UserName] | -v [UserName] | File]
		-e [Username]:执行文字编辑器来设定时程表，内定的文字编辑器是vi，可以设定VISUAL环境变量来指定\
			使用那个文字编辑器（比如setenv VISUAL joe）
	#在一天做N次的计划任务
		#以下例子代表在12点和18点执行任务
		00 12，18 * * * /home/tontinme/test.sh	
	#在一天的特定时间段的计划任务
		#以下代表在12点到18点的每个小时的整点执行脚本
		00 12-18 * * * /home/tontinme/test.sh
		#以下代表在工作日（不包括周六日）的12点到18点的整点执行脚本
	#查看root以外用户的计划任务内容	
		#编辑使用-e选项
		#crontab -u tontinme -l
		00 12,18 * * * /home/tontinme/test.sh	
	#在相隔时间后执行计划任务
		#以下表示每10分钟执行一次任务
		*/10 * * * * /home/tontinme/test.sh
	#某特定相隔时间的计划任务
		#以下表示每年的第一分钟执行脚本
		@yearly /home/tontinme/test.sh
			#使用@yearly对应的是0 * * * *,还有如下可用：
			@reboot		run once, at startup
			@yearly		run once a year, "0 0 1 1 *"
			@annually	same as @yearly
			@monthly	run once a month, "0 0 1 * *"
			@weekly		run once a week, "0 0 * * 0"
			@daily		run once a day, "0 0 * * *"
			@midnight	same as @daily
			@hourly		run once an hour, "0 * * * *"
		#这里特别强调@reboot,可以设定重启后执行。
	#以秒为单位执行计划任务
		#以下表示每20秒执行一次：
		* * * * * sleep 20; /home/tontinme/test.sh
	#其他实例
		#晚上11点到早上7点之间，每隔一小时执行一次脚本
		* 23-7/1 * * * /home/tontinme/test.sh
		#每月的4号与每周一到周三的11点执行脚本
		0 11 4 * mon-wed /home/tontinme/test.sh
		#一月一号的4点执行脚本
		0 4 1 jan * /home/tontinme/test.sh
	#crontab无法运行分析
		1.crontab是nologin shell，运行时的一些环境变量与直接登录后在命令行下运行不同所致。
		  crontab默认调用PATH是/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin或者更少。
		  解决办法：
			所有命令和工具使用绝对路径，或者在脚本前面执行一下profile文件：source ~/.bash_profile
		2.添加在crontab中的命令含有%，%在crontab上有特殊意义，不同的shell对crontab的实现有差异，因此\
			为了安全起见，应该在命令中对%进行转义，或者尽量不要在crontab中使用%。
		3.crontab添加任务时最好将输出(标准输出和错误输出)重定向(2>&1)，没有输出可以重定向到/dev/null,否则crontab将输出以mail的\
			方式发送给你。并且有些程序没有重定向输出会导致执行失败。
#dd
	作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换
		可以用于生成虚拟块设备文件。即可以用于创建空镜像文件，也可以用于创建物理硬盘的镜像
	#部分参数说明
		if=file		输入文件名，缺省为标准输入
		of=file		输出文件名，缺省为标准输出
		bs=bytes	同时设置读写块的大小为bytes,可代替ibs和obs(ibs-一次读入bytes个字节；obs-一次写入bytes个字节)
		count=blocks	仅拷贝blocks个块，块大小等于ibs指定的字节数
	#eg.造一个1G的虚拟块设备文件
		dd if=/dev/zero of=1G.img bs=1M count=1000
		#/dev/zero是Linux提供的一个特殊的字符设备，它的特点是可以永远读取该文件，每次读取的结果都是二进制0
		但是这样会实际写入硬盘，文件产生的速度取决于硬盘读写速度，如果想要产生超大文件，速度很慢
		dd if=/dev/zero of=1G.img bs=1M count=0 seek=1000
		#此时创建的文件在文件系统中的显示大小为1G，但是并不实际占用block。
		seek作用是跳过输出文件中指定大小的部分,这就达到了创建大文件，但是并不实际写入的目的
		#注意：
			创建并不实际占用block的大文件后，将其拷贝到新目录，du显示为1G
#find
	#忽略大小写的查找
		$find -iname 'xxx'
		./xxx
		./XXX
		./Xxx
	#查找文件目录的深度限制（从/开始计算。包括maxdepth和mindepth）
		[root@server test]# find / -name ‘passwd’
		/usr/share/doc/nss_ldap-253/pam.d/passwd
		/usr/bin/passwd
		/etc/pam.d/passwd
		/etc/passwd
		[root@server test]# cd /
		[root@server /]# find -mindepth 3 -maxdepth 3 -name ‘passwd’
		./usr/bin/passwd
		./etc/pam.d/passwd
	#根据文件属性查找
		#查找其中组权限是r的，也可以包括其他权限
		#find . -perm -g=r -type f -exec ls -l {} \;
		—-r—– 1 root root 0 01-08 20:45 ./FAn
		-rwxrwxrwx 1 root root 0 01-08 17:00 ./Fan
		-rw-r—– 1 root root 0 01-08 17:01 ./FAN
		-rw-r–r– 1 root root 0 01-08 17:01 ./fan
		#查找其中组权限是r的，不能包括其他权限
		#find . -perm g=r -type f -exec ls -l {} \;
		—-r—– 1 root root 0 01-08 20:45 ./FAn
	#查找空文件（0字节文件）
		#find ~ -empty
		#注：按照深度去查找，比如我只想查找2层深度的文件
			#find . -maxdepth 2 -empty
			./root/spread-bin-4.0.0
	#工作中可能想要删除一些临时文件，想要删除最大的5个文件，这样查找：
		#find . -type f -exec ls -s {} \; | sort -n -r | head 5
		201424 ./ctier-server-3.6.0-1.noarch.rpm
		14568 ./.cpan/Metadata
		4700 ./ruby-1.8.7.tar.gz
		4316 ./ruby-1.8.7/libruby-static.a
		3372 ./passenger-2.2.11/ext/apache2/ApplicationPoolServerExecutable
	#查找指定文件类型的文件：使用-type选项
	#根据文件修改时间查找
		#ls -lrt
	#指定查找某文件修改时间之前修改或者创建的文件
		#find -newer filename
	#根据文件大小查找
		#比如，查找大于20M的文件
			#find . -size +20M
		#查找小于1M的文件
			#find . -size -1M
#free
	#display the total amount of free and used physical and swap memory in the system,\
		as well as the buffers used by the kernel
#grep
	#find+xargs+grep	并行grep
	xargs使用-P参数，可以启动多个grep来并发控制
	  eg. find ./ -name "*.log" -print0 | xargs -0 -n1 -P14 grep -H "baidu" > /dev/null
#iostat
	report cpu statistics and I/O statistics for devices,partitions and NFS
	使用strace查看iostat从哪里得到的IO相关信息
	  $strace -eopen iostat
	常用的iostat命令格式
	  $iostat -dx 1		#每隔一秒显示一次IO扩展信息
	  [ec2-user@ip-10-161-106-51 ~]$ iostat -dx 1
  	  	Linux 2.6.34.7-56.40.amzn1.x86_64 (ip-10-161-106-51)    07/19/2011      _x86_64_        (1 CPU)
  	  	Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
  	  	xvdap1            0.00     0.05    0.00    0.08     0.05     1.09    13.20     0.00    6.02   2.92   0.03
  	  	xvdf              0.00     0.00    0.00    0.00     0.00     0.00    46.52     0.00   49.68   3.32   0.00
  	  	
  	  	Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
  	  	xvdap1            0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
  	  	xvdf              0.00     0.00    0.00    0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
	  #Note: 开头显示的是自系统启动开始的平均值，后面显示的是每段时间间隔里的平均值
	  相关参数含义：
		rrqm/s		队列中每秒钟合并的读请求数量
		wrqm/s		队列中每秒钟合并的写请求数量
		r/s		每秒钟完成的读请求数量
		w/s		每秒钟完成的写请求数量
		rsec/s		每秒钟读取的扇区数量
		wsec/s		每秒钟写入的扇区数量
		avgrq-sz	平均请求扇区的大小
		avgqu-sz	平均请求队列的长度
		await		平均每次请求的等待时间
		svctm		平均每次请求的等待时间
		util		设备的利用率
	  这些参数的含义（相对重要的是后面几个）
		util: 设备的利用率。如果它接近100%，通常说明设备能力趋于饱和（并不绝对，比如设备有写缓冲）
		      有时会出现大于100%的情况，这是因为读取数据的时候并非原子操作
		svctm: 平均每次请求的服务时间，(r/s+w/s)*(svctm/1000)=util
		       eg.如果util达到100%，那么svctm=1000/(r/s+w/s),假设IOPS是1000，那么svctm大概在1ms左右，\
			如果长时间大于这个数值，说明系统出了问题
		#Note:svctm参数在未来某个版本的iostat会被删除
		await: 平均每次请求的等待时间，这个时间包括了队列时间和服务时间
		       也就是说，一般情况下，await大于svctm，它们的差值越小，则说明队列时间越短，反之差值越大\
			队列时间越长，说明系统出了问题
		avgqu-sz: 平均请求队列的长度。毫无疑问，队列长度越短越好
	#Note:有时候iostat会显示一些很离谱的结果，官方FAQ的解释是：http://sebastien.godard.pagesperso-orange.fr/faq.html	
#iptraf
	#iptraf command is interactive colorful IP LAN monitor. It is an ncurses-based IP LAN\
		monitor that generates various network statistics including TCP info, UDP counts,\
		ICMP and OSPF information,Ethernet load info, node stats, IP checksum errors, and \
		others. 
#ls
	#显示最后一次执行的命令中修改的文件
		$ls -t
	#每行显示一个条目
		$ls -l
	#显示文件大小：根据大小自动显示为KB,MB,GB
		$ls -lh
	#显示文件上次修改时间
		$ls -lt		
		#将当前的时间排序反过来
			$ls -ltr
	#递归显示文件
		$ls -R
	#显示文件的uid和gid：
		$ls -n
	#在颜色不明显分辨时，使不同的文件显示不同的效果（/-目录，@-链接文件，*-可执行文件，=-socket文件）
#lsof
	$lsof
	COMMAND	PID	USER	FD	TYPE	DEVICE	SIZE/OFF	NODE	NAME
	init	1	root	cwd	VDIR	136,8	1024		2	/
	vi	2013	cinder	3u	VREG	136,8	0		8501	/var/tmp/ExXDa07d
	解释：
	  Command,PID和User列分别表示进程的名称，进程标识符和所有者名称
	  Device,SIZE/OFF,Node和Name列涉及到文件本身的信息，分别表示指定磁盘的名称，文件的大小，索引节点（文件\
		在磁盘上的标识）和该文件的确切名称，根据UNIX版本的不同，可能将文件的大小报告为应用程序在文件中\
		进行读取的当前位置（偏移量）
	  FD列表示文件描述符，其值可能是cwd(表示应用程序的当前工作目录)，txt(程序代码)，数字+状态(数字是文件\
		描述符，状态有u(读取/写入),r只读(),w(只写))。大多数应用程序的FD是从3开始的，0,1,2分别表示标准\
		输入，输出和错误流
	  Type列提供了关于文件格式的更多描述。根据具体操作系统不同，可能将文件和目录称为REG和DIR（Solaris称为\
		VREG和VDIR），其他可能的取值是CHR和BLK，分别表示字符和块设备，或者UNIX,FIFO,IPv4，分别表示UNIX\
		域套接字，先进先出队列和IP套接字
        1.查看对某个文件的使用情况
          查看哪些进程对某个文件进行了调用
          eg.   $lsof /var/log/mysqld.log
        2.查看对文件系统的使用
          /tmp目录被垃圾文件塞满了，但是，用ls又看不到太大文件，谁干的
          eg.   $lsof /tmp
        3.查找打开，但是不能连接的文件
          一个进程打开一个文件，然后将其设为unlinked状态，则此文件资源仍能被进程使用，但是其访问路径已经被删除了\
                因此，使用ls不能将其列出，只有当进程结束时，才能释放文件占用的资源
          查找unlinked文件，选项+L，作用：列出打开文件的连接数
          eg.   $lsof +L
          指定连接数的上限
          $lsof +L1
	  同时指定多个参数，需要加上-a参数，否则缺省的情况是显示匹配任何一个参数(OR)
          $lsof -a -p 605 -d ^txt	#-a参数表示所有参数都必须满足(AND)
        4.无法卸载
          查看谁令mount的分区无法卸载
          $lsof <file_system_name>
        5.查看监听socket
          查看监听端口的进程
          $lsof -i
	  $lsof -i:80		#查看80端口被谁占用
        6.搜索活动的连接
          $lsof -i @192.168.1.10
          $lsof -i tcp@aaa.bbb.ccc:ftp-data     #指定协议
          $lsof -i 4    #指定IP版本
          $lsof -i 6
        7.识别netstat链接
          6中的aaa.bbb.ccc:port可以通过"$netstat -ptn"得到
        8.查找针对某个命令打开的文件
          使用命令的PID
          $lsof -p <PID>
          使用命令名称
          $lsof -c <first_characters_of_command_name_that_interest_you>
          $lsof -c mysqld
          查看打开某个文件的应用程序
          $lsof /tmp/mysql.sock
        9.查看某个用户的操作
          $id -u cinder
          502
          $lsof -u 502 or $lsof -u cinder
          $lsof -u ^cinder #是取反的意思
	10.恢复删除的文件
	  当进程打开了某个文件，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中
	  eg.删除了apache的error_log
	  $lsof | grep error_log	#获得error_log的pid和文件描述符(FD)
	  $cat /proc/$PID/fd/$FD > /$path/error_log	#使用IO重定向将其复制到临时位置，再移到所需位置
man
        -a      显示所有匹配项
        -d      显示man查照手册文件时候，搜索路径信息，不显示手册页内容
        -D      同-d，显示手册页内容
        -f      同命令whatis，将在whatis数据库查找以关键字开头的帮助索引信息
        -h      显示帮助信息
        -k      同命令apropos，将搜索whatis数据库，模糊查找关键字
        ...       
        通常遇到一个不是很熟悉的命令，可以先通过：
        $man -k command1        查找所有类似帮助文件信息，这样输出最多
        $man -f command1        查询以command1开头所有相关帮助信息列表
        $man 5 command1         通过直接定位5获得帮助信息
#mpstat
	#display activities for each available processor, processor, processor 0 being the first\
		one. 
		$mpstat -P ALL	#display average CPU utilization per processor
#netstat
	#display network connections, routing tables, interface statistics, masquerade connections, and multicast memberships.
#nmon
	http://nmon.sourceforge.net/pmwiki.php
	#nmon工具可以为AIX和Linux提供监视和分析性能数据的功能，其中包括：
		*CPU使用率
		*内存使用情况
		*内核统计信息和运行队列信息
		*文件系统中的可用空间
		*磁盘适配器
		*网络I/O速度、传输和读/写比率
		*页面空间和页面速度
		*CPU和AIX规范
		*消耗资源最多的进程
		*IBM HTTP Web缓存
		*用户自定义的磁盘组
		*计算机详细信息和资源
		*异步I/O，仅适用于AIX
		*工作负载管理器（WLM），仅适用于AIX
		*IBM TotalStorage Enterprise Storage Server(Ess)磁盘，仅适用于AIX
		*网络文件系统（NFS）
		*动态LPAR(DLPAR)更改，仅适用于面向AIX或Linux的pSeries p5和OpenPower
		#还包括一个用来从nmon的输出生成图形并创建可以在Web站点显示的.gif文件的新工具
#od
	od(octal dump)命令可以以八进制，十进制，十六进制和ASCII码来显示文件或者流，它们对于访问或可视地检查文\
		件中不能直接显示在终端上的字符很有用
	$od [-A 地址进制] [-t 显示格式] 文件
		-A指定地址包括：
		  o	八进制
		  d	十进制
		  x	十六进制
		  n	不打印位移值
		-t指定数据的显示格式，主要参数有:
		  c	ASCII字符或反斜杠序列(如\n)
		  d	有符号十进制数
		  f	浮点数
		  o	八进制
		  u	无符号十进制数
		  x	十六进制数
		-j 字节数	跳过指定字节数
		-N 字节数	仅显示指定字节数
		-w 字节数	每一行仅显示指定字节数	
		-v 	表示即使连续多行都是完全相同的字符0，仍然原样输出；不加该参数，则会使用*跳过多个相同的行
#paste
	#用于文件合并
	#paste f1 f2 f3
#pmap
	#report memory map of a process. Use this command to find out causes of memory bottlenecks
		$pmap -d PID
#ps
	#select all processes
		$ps -A ( $ps -e )
	#show long format output
		$ps -Al
		$ps -AlF	#turn on extra full mode
	#see threads(LWP and NLWP)
		$ps -AlFH
	#see threads after processes
		$ps -AlLm
	#print all process on the server 
		$ps ax
		$ps aux
	#print a process tree
		$ps -ejH
		$ps axjf
		$pstree
	#print security information
		$ps -eo euser,ruser,suser,fuser,f,comm,label
		$ps axZ
		$ps -eM
	#see every process running as user cinder
		$ps -U cinder -u cinder u
	#see output in a user-defined format
		$ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
	#display only the process IDs of lighttpd
		$ps -C lighttpd -o pid=
		$pgrep lighttpd
		$pgrep -u cinder php-cgi
	#display the name of pid 55977
		$ps -p 55977 -o comm=
	#find out the top 10 memory consuming process
		$ps -auxf | sort -nr -k 4 | head -10
	#find out top 10 cpu consuming process
		$ps -auxf | sort -nr -k 3 | head -10
#rpm
	1.通过文件查找它属于哪个软件包
		$rpm -qf /usr/bin/multitail
		multitail-5.2.6-1.el5.rf
	2.查看rpm包大量信息
		$rpm -qip XXX.rpm
	3.查看rpm包软件里面文件列表
		$rpm -qlp XXX.rpm
	4.列出rpm包的依赖关系
		$rpm -qRp XXX.rpm
#rsync
	#参数
		-z	开启压缩功能
		-v	打印详细信息
		-r	递归同步
		-a	同步时间戳
#sar
	搜集、报告和存储系统活动信息
#ss
	#ss command is used to dump socket statistics. It allows showing information similar to\
		netstat.

#strace
	#trace system calls and signals.This is useful for debugging webserver and other server problems.
	#trace 能够显示所有由用户空间程序发出的系统调用
	-f	告诉strace同时跟踪fork和vfork出来的进程
	-o xxx.txt	输出到某个文件
	-e execve	只记录execve这类系统调用
	-p pid	跟踪指定的进程，此参数常用来调试后台进程
	-r	打印每一个系统调用的相对时间
	-t	在输出中的每一行前加上时间信息
	-tt	时间精确到微秒级
	-ttt	打印相对时间
	-v	输出所有系统调用。默认情况下，一些频繁调用的系统调用不会输出
	-c	统计每种系统调用所执行的时间，调用次数，出错次数
	-e expr	输出过滤器，通过表达式，可以过滤掉你不想要的输出
#su & sudo
	#su
		直接切换为超级用户
		普通用户要切换为超级用户必须知道超级用户的口令
		适用于系统中只有单个系统管理员的情况
	#sudo
		直接使用sudo命令前缀执行系统管理命令
		执行系统管理员命令时无需知道超级用户的口令，使用普通用户自己的口令即可
		由于执行系统管理员命令时无需知晓超级用户口令，所以适用于系统中有多个系统管理员的情况，当然\
		单个管理员时也可以使用。
	#su	
		su [-|-p] [-c command] [username]
		- : 在切换当前用户时切换用户工作环境
		-p ：在切换当前用户时不切换用户工作环境，即保持当前用户工作环境，此为缺省值
		-c command : 以指定的用户身份执行命令command
		username : 为要切换的用户，省略时表示root
	#sudo
		#简介：允许系统管理员为几个用户或组委派权利，使之能运行部分或全部由root（或另一个）用户执行\
			的命令。宗旨：给用户尽可能少的权限但仍允许完成他们的工作，sudo是设置了SUID位的执行文件
		#特点：
			sudo能够限制用户在指定主机上运行某些命令
			sudo可以提供日志，忠实的记录每个用户使用sudo做了些什么，并且能将日志传到中心主机或者日志\
				服务器。
			sudo为系统管理员提供配置文件，允许系统管理员集中的管理用户的使用权限和使用的主机。它默认\
				的存放位置是/etc/sudoers
			sudo使用时间戳文件来完成类似“检票”的系统。当用户执行sudo并且输入密码后，用户获得了一张默认\
				存活期为5分钟的“入场券”（默认值可以在编译时改变）。超时以后，用户必须重新输入密码。
		#用户执行sudo的执行过程
			1.在/var/run/sudo/$HOME目录中查找时间戳文件
			2.读取配置文件/etc/sudoers，判断用户是否有执行此sudo命令的权限
	#sudo命令格式
		sudo -V | -h | -k | -l | -v
		sudo [-Hh] [-u username|#uid] {-i | -s <command>}

		-v : 显示版本信息，并退出。
		-h : 显示帮助信息
		-l : 显示当前用户（执行sudo的使用者）的权限，只有在/etc/sudoers里的用户才能使用该选项。
		-v : 延长密码有效期限5分钟。
		-k : 将会强迫使用者在下一次执行sudo时问密码（不论有没有超过5分钟）
		-H : 将环境变量中的$HOME指定为要变更身份的使用者目录（如不加-u参数就是/root）
		-b : 在后台执行指令
		-u : username |#uid :以指定的用户作为新的身份。省略此参数表示以root的身份执行指令。
		-i : 模拟一个新用户身份的初始shell
		-s : 执行环境变量$SHELL所指定的shell，或是/etc/passwd里所指定的shell
		command : 以新用户身份要执行的命令。
	#配置sudo
		#/etc/sudoers的组成部分
			1.别名定义部分：包括User_Alias,Host_Alias,Runas_Alias,Cmnd_Alias
			2.配置选项部分：由Defaults设置
			3.User Host = (Runas)			Cmd
			  用户 主机  （可切换的其他用户）	可执行的命令
		#说明：
			1.在cmnd部分之间可以使用NOPASSWD:参数，表示不用输入密码即可执行cmnd
			2.(Runas)部分可以省略，省略时表示(root)，即表示仅能切换为root用户身份
			3.四个部分均可设置多个项目，每个项目用逗号间隔
			4.四个部分均可使用别名定义来简化配置，即用User_Alias定义用户别名、用Host_Alias定义主机别名\
				用Runas_Alias定义切换用户别名、用Cmnd_Alias定义命令别名。别名必须使用大写字母。
			别名格式：
				User_Alias USER_ALIAS_NAME = user1, user2, ......
				Host_Alias HOST_ALIAS_NAME = host1, host2, ......
				Runas_Alias RUNAS_ALIAS_NAME = runas1, runas2, ......
				Cmnd_Alias COMMAND_ALIAS_NAME = cmnd1, cmnd2, ......
		#配置片段：
			详见：https://docs.google.com/document/pub?id=12wW2gTEVMc-8cRhkd0qUX-lQQAKlQVSZY1BIPcuaUMI
			让osmond用户和wheel组的成员可以在任何主机上以任何人的身份运行任何命令
			专职系统管理员(millert,mikef和dowdy)可以在任何主机上执行任何命令而不需要进行身份验证
			兼职系统管理员(bostley,jwfox和crawl)可以在任何主机上运行任何命令
			兼职管理员(jalala, sonar和huge)可以在任何主机上运行 BROWSE、PROCESSES、USERS 中的命令
			允许sys 组的成员运行 networking, software, service 等管理命令
			WEBMASTERS(will, wendy,和 wim)中的用户都能够在主机www上以www的身份执行任何命令，或者使用 su www 命令
#tail
	-f	可以及时看到文件的变化。如果再加上一个grep命令，可能看到的就不那么及时了。因为grep在buffer写不\
			满时就不输出，可以通过选项--line-buffered来搞定。
		eg. $tail -f file.txt | grep something --line-buffered
#tcpdump
	#detailed network traffic analysis
	#display traffic info about http
		$tcpdump -i eth0 'tcp port 80'
	#display all FTP session to 202.54.1.5
		$tcpdump -i eth1 'dst 202.54.1.5 and port 20 or 21'
#tmpwatch
	/usr/sbin/tmpwatch -m 30d /opt/resin/log/	删除某目录下30天后的过期日志，日期默认是小时，这里指定为天
#top
	#根据一些参数将性能排序
		使用-O选项进入选择菜单，选择相关字母（大写向上调整，小写向下调整）即可根据参数排序
	#高亮显示
		按z或者b
	#改变刷新top命令的时间间隔（默认是3s）
		按d，显示：$delay from 3.0 to:
	#显示/隐藏进程的路径
		按c键
	#设定top查看性能次数-当刷新指定次数后自动退出
		$top -n 你指定的次数
	#display summary information off/on
		按t
	#display memory information off/on
		按m
	#快速列出使用各类资源的top consumers
		按A
	#定制top默认能显示的项
		按f
	#issues kill command
		按k
	#top中PR和NI(priority和nice)的区别
		PR表示目前系统分配给该process的优先权，而若是特别要调整该process的优先权的话，通过提高或降低NI的数值可让PR变化。
		PR由系统内定自行调整，要把所有process的NI值都考虑进来，调度程序才能决定一个process的PR。
#uptime
	#tell how long the system has been running
	the uptime command can be used to see how long the server has been running .\
		the current time, how long the system has been running, how many users\
		are currently logged on, and the system load averages for the past 1,5,\
		and 15 minutes
#vmstat
	#reports information about processes,memory,paging,block IO,traps,and cpu activity
		for example	$vmstat 3
		$vmstat -m	#display memory utilization slabinfo
		$vmstat -a	#get information about active/inactive memory pages
#w
	#display information about the users currently on the machine, and their processes
		$w username
		$w cinder
#watch
	#当想重复一个命令或者shell脚本（只间隔几秒），可以使用watch
	1.方便查看日志文件以及其他增长型文件的速度
		$watch ls
	2.-d选项高亮，对变化的数值突出显示
		$watch -d free -m
	3.-n选项指定watch间隔，-t选项去掉第一行多余信息
		$watch -n 10 -t free -m
#wget
	#通常下载单个文件的方式
		$wget http://hotfile.com/dl/97851370/9727f76/backups-DN22006-sUN.part03.rar	
	#下载一个和下载地址文件名不同的文件
		默认wget会自动分隔最后一个斜线的后面作为文件名，正常下载模式：
			$wget http://www.aaa.com/test/download.php?src_id=02
			下载后：
			$ls
			download_.php?src_id=02
		可以使用-O选项解决：
			$wget –O test.zip http://www.aaa.com/test/download.php?src_id=02
			下载后：
			$ls
			test.zip
	#指定下载速度
		$wget -limit-rate=100k http://limit.com/test.tar.gz
	#断点续传
		使用-c选项	
	#后台下载
		-b选项进行后台下载，wget在后台继续运行，并把输出写至"wget-log"，查看日志
		$tail -l wget-log	
	#当下载多个内容时，可以将这些地址放到一个文件中，然后下载这个文件。
		$cat download_file_list.txt
		url1
		url2
		url3
		...
		$wget -i download_file_list.txt
	#下载一个站点
		$wget --mirror -p -convert-links -P localhost www.tontin.me
	#限制下载的类型
		$wget -R *.jpg www.tontin.me
		$wget --reject=jpg www.tontin.me
	#记录下载日志
		$wget -o /var/log/wget.log www.tontin.me
	#仅下载某些类型的文件
		$wget -r -A *.pdf mirrors.sohu.com/ebook
		# -r recursive
		# -A --accept acclist
		# -A *.pdf will match file1.pdf, but also file2.PDF, if you use --ignore-case
	#使用用户名和密码下载文件，包括ftp和http
		$wget --user=USERNAME --password=PASSWORD www.tontin.me
		#these parameters can be overridden using the --ftp-user and --ftp-password options for FTP\
		# connections and the --http-user and --http-password options for HTTP connections.
#whoami,id,groups,newgrp
	whoami		#用于显示当前用户的名称
	groups		#用于显示指定用户所属的组
	id		#用于显示用户身份
	newgrp		#用于转换用户的当前组到指定的附加组，用户必须属于该组才可以进行
#zip,tar.gz,tar.bz2
	zip	
		压缩
		$zip -r archive_name.zip directory_to_compress
		解压
		$unzip archive_name.zip
	tar
		压缩
		$tar -cvf archive_name.tar directory_to_compress
		解压
		$tar xvf archive_name.tar
		解压到指定目录
		$tar xvf archive_name.tar -C /tmp/extract_here/
	tar.gz
		$tar -zcvf archive_name.tar.gz directory_to_compress
		$tar -zxvf archive_name.tar.gz -C /tmp/extract_here/
	tar.bz2
		$tar -jcvf archive_name.tar.bz2 directory_to_compress	
		$tar -zxvf archive_name.tar.bz2 -C /tmp/extract_here/
	.gz
		$gzip FileName
		$gunzip FileName.gz
		$gzip -d FileName.gz
	.bz2
		$bzip2 -z FileName
		$bzip2 -d FileName.bz2
		$bunzip2 FileName.bz2
	.Z
		$compress FileName
		$uncompress FileName.Z
	.tar.Z
		$tar Zcvf FileName.tar.Z DirName
		$tar Zxvf FileName.tar.Z
	.tgz
		$tar zxvf FileName.tgz
	.tar.tgz
		$tar zcvf FileName.tar.tgz FileName	
		$tar zxvf FileName.tar.tgz 
	.rar
		$rar e FileName.rar FileName
		$rar a FileName.rar
	rpm	
		解包
		$rpm2cpio FileName.rpm | cpio -div

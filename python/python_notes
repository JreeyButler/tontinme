#! /usr/bin/env python

#re正则表达式
  #1.1 基本规则
	'|'	或规则
		在[]中它不表示或，而表示它本身的字符。也可以使用"\ "表示它本事
		它的有效范围是它两边的整条规则，比如'dog|cat'匹配的是"dog或cat"，而不是"g和c"。如果
			要想限定它的有效范围，必须使用一个无捕获组"(?:)"包起来, 比如要匹配"I have a dog"和
			"I have a cat"，需要写成"I have a (?:dog|cat)"
	'r'	raw字符串
		>>re.findall(r'abc',s)
		使用'r'字符串，就可以不转义正则中那些本来需要转义的字符。当然，某些情况下，可能不用raw效果更好
	'.'	匹配所有字符
		匹配除换行符'/n'外的所有字符。如果使用了'S'选项，匹配包括'/n'的所有字符
		>>re.findall(r'.abc',s,re.S)
	'^'|'$'	匹配字符串开头和结尾
		'^'在'[]'中表示'非'
	'/d'	匹配数字
	'/D'	匹配非数字
	'/w'	匹配字母和数字
	'/W'	匹配非英文字母和数字
	'/s'	匹配间隔符
		等价于[ /t/r/n/f/v], 注意最开始有空格符
	'/S'	匹配非间隔符
	'/A'	匹配字符串开头. 和'^'的区别：'/A'只匹配整个字符串的开头，不会匹配其他行的行首
	'/Z'	匹配字符串结尾. 和'$'的区别：'/Z'只匹配整个字符串的结尾
	'/b'	匹配单词边界
		它是一个'0'长度字符，它匹配完的字符串不会包括那个分界的字符。而如果用'/s'来匹配的话，则匹配出的
		字符串包含那个分界符
		>>s = "abc abcde bc bcd"
		>>re.findall(r'/bbc/b',s)
		['bc']
		>>re.findall(r'/sbc/s',s)
		[' bc ']
	'/B'	匹配非边界符
		>>re.findall(r'/Bbc/w+',s)	匹配包含'bc'但不以'bc'为开头的单词
	'(?:)'	无捕获组
		当你想要将一部分规则作为一个整体对它进行某些操作，你需要将这部分规则用'(?:)'把它包围起来
	'(?#)'	注释
		Python允许你在正则表达式中写入注释，在'(?#)'之间的内容将被忽略
	(?iLmsux)	编译选项指定
		python的正则可以指定一些选项，这个选项可以写在findall或compile的参数中，也可以写在正则式里，成为正则的一部分
		i == ignorecase, L == local, m == mulitline, s == dotall, u == unicode, x == verbose.
		请注意大小写，比如忽略大小写同时使用多行模式'(?im)'
		另外注意选项的有效范围是整条规则，即写在规则的任何地方，选项都对全部整条正则式有效
	
  #1.2 重复
	'*'	0次或多次匹配
	'+'	1次或多次匹配
	'?'	0次或1次匹配
	'{m}'	精确匹配m次
	'{m,n}'	匹配最少m次，最多n次
	'*?' '+?' '??'	最小匹配
		python默认是贪婪匹配，辅以'?'则尽可能少的匹配
  #1.3 界定
	'(?<=...)'	前向界定
		括号中'...'代表你希望匹配的字符串的前面应该出现的字符串
	'(?=...)'	后向界定
		括号中'...'代表你希望匹配的字符串的后面应该出现的字符串
		>>s = r'/* comment 1 */ code /* comment 2 */'
		>>re.findall(r'(?<=//*).+?(?=/*/)',s)
		[' comment 1 ', ' comment 2 ']
		注意：前向界定括号中的表达式必须是常值，不能用正则表达式。后向界定括号中的表达式可以是正则式。
	'(?<!...)'	前向非界定
		只有当你希望的字符串前面不是'...'的内容时才匹配
	'(?!...)'	后向非界定
		只有当你希望的字符串后面不是'...'的内容时才匹配
  #1.4 组的基本知识
	'('')'	无命名组
		最基本的组是由一对圆括号括起来的正则表达式
		>>s = 'aaa111bbb, bbb222, 333ccc'
		>>re.findall(r'[a-z]+(/d+)[a-z]+',s)
		['111']
		可以看到findall只返回了包含在'()'中的内容，虽然前后都匹配成功了，但是并不包含在结果中
	'(?P<name>...)'	命名组
		'(?P'代表这是一个python语法扩展，'<>'里面是你给这个组起的名字. 比如你给一个全部是数字的组起名'num', 可以写作
		'(?P<num>/d+)'. 起了名字后，就可以在后面的正则中通过名字调用这个组，它的形式是'(?P=name)'调用已匹配的命名组
		注意：再次强调这个组是已匹配的组，也就是说它里面的内容是和前面命名组里的内容是一样的
		>>re.findall(r'(?P<g1>[a-z]+)/d+(?P=g1)',s)	找出被中间夹有数字的前后同样的字母
	'/number'	通过序号调用已匹配的数组
		正则表达式中的每个组都有一个序号，序号是从左到右，从数字1开始。比如
		>>re.findall(r'(?P<g1>[a-z]+)/d+/1',s)	等同于上面的表达式
	'(?(id/name)yes-pattern|no-pattern)'	判断指定组是否已匹配，执行相应的规则
		如果'id/name'指定的组在前面匹配成功了，则执行yes-pattern的正则表达式，否则执行no-pattern的正则表达式
  #2 re模块的基本函数
	findall(rule, target [,flag])		在目标字符串中查找符合规则的字符串
	compile(rule [,flag])			将正则规则编译成一个pattern对象，以供接下来使用.返回一个pattern对象
		如果多次使用同一规则来进行匹配的话，可以使用re.compile()函数来将规则进行预编译，使用编译过返回的regular expression object或
		pattern对象来进行查找
	match(rule, targetString [,flag])
	search(rule, targetString [,flag])
						按照规则在目标字符串中进行匹配
